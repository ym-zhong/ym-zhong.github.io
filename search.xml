<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>队列</title>
    <url>/2020/11/17/queue/</url>
    <content><![CDATA[<h1 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h1><ul>
<li><h2 id="队列的定义"><a href="#队列的定义" class="headerlink" title="队列的定义"></a>队列的定义</h2>&emsp;&emsp;队列是一种<strong>先进先出的</strong>的数据结构。<a id="more"></a>我们可以对队头进行出队操作，对队尾进行入队操作。</li>
</ul>
<hr>
<ul>
<li><h2 id="队列的实现"><a href="#队列的实现" class="headerlink" title="队列的实现"></a>队列的实现</h2></li>
</ul>
<ol>
<li>用数组实现队列  </li>
<li>用链表实现队列</li>
</ol>
<hr>
<ul>
<li><h2 id="循环队列的实现"><a href="#循环队列的实现" class="headerlink" title="循环队列的实现"></a>循环队列的实现</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;vector&gt;</span><br><span class="line"></span><br><span class="line">class MyCircularQueue &#123;</span><br><span class="line">private:</span><br><span class="line">    int head, tail, size;</span><br><span class="line">    int* data;</span><br><span class="line"></span><br><span class="line">public:</span><br><span class="line">    MyCircularQueue(int size_): head(0), tail(0), size(size_+1), data(nullptr) &#123;</span><br><span class="line">        data &#x3D; new int[size];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    bool enQueue(int value) &#123;</span><br><span class="line">        if (this-&gt;isFull()) &#123;</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        data[tail] &#x3D; value;</span><br><span class="line">        ++tail;</span><br><span class="line">        tail %&#x3D; size;</span><br><span class="line">        </span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    bool deQueue() &#123;</span><br><span class="line">        if (this-&gt;isEmpty()) &#123;</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ++head;</span><br><span class="line">        head %&#x3D; size;</span><br><span class="line">        </span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    int Front() &#123;</span><br><span class="line">        if (this-&gt;isEmpty()) &#123;</span><br><span class="line">            return -1;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return data[head];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    int Rear() &#123;</span><br><span class="line">        if (this-&gt;isEmpty()) &#123;</span><br><span class="line">            return -1;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return data[(tail + size - 1) % size];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    bool isEmpty() &#123;</span><br><span class="line">        if (head &#x3D;&#x3D; tail) &#123;</span><br><span class="line">            return true;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    bool isFull() &#123;</span><br><span class="line">        if ((tail + 1) % size &#x3D;&#x3D; head) &#123;</span><br><span class="line">            return true;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ~MyCircularQueue() &#123;</span><br><span class="line">        delete []data;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
</ul>
]]></content>
      <categories>
        <category>数据结构</category>
        <category>线性结构</category>
      </categories>
  </entry>
  <entry>
    <title>树的遍历</title>
    <url>/2020/11/26/traversal/</url>
    <content><![CDATA[<h1 id="树的遍历"><a href="#树的遍历" class="headerlink" title="树的遍历"></a>树的遍历</h1><a id="more"></a>

<p>&emsp;&emsp;树的遍历一共分为4种，分别为前序遍历、中序遍历、后序遍历和层序遍历。本文仅针对二叉树讲讲这四种遍历方式。</p>
<hr>
<p>&emsp;&emsp;树结点的定义为：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">struct TreeNode &#123;</span><br><span class="line">    elementType val;</span><br><span class="line">    TreeNode *lson, *rson;</span><br><span class="line"></span><br><span class="line">    TreeNode(elementType val_, TreeNode *lson_ &#x3D; nullptr, TreeNode *rson_ &#x3D; nullptr): val(val_), lson(lson_), rson(rson_) &#123;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="前序遍历"><a href="#前序遍历" class="headerlink" title="前序遍历"></a>前序遍历</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;recursive version</span><br><span class="line">vector&lt;int&gt; preorderTraversal(TreeNode* root) &#123;</span><br><span class="line">    vector&lt;int&gt; ans;</span><br><span class="line"></span><br><span class="line">    if (root &#x3D;&#x3D; nullptr) &#123;</span><br><span class="line">        return ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    vector&lt;int&gt; v1 &#x3D; preorderTraversal(root-&gt;lson);</span><br><span class="line">    vector&lt;int&gt; v2 &#x3D; preorderTraversal(root-&gt;rson);</span><br><span class="line"></span><br><span class="line">    ans.push_back(root-&gt;val);</span><br><span class="line">    ans.insert(ans.end(), v1.begin(), v1.end());</span><br><span class="line">    ans.insert(ans.end(), v2.begin(), v2.end());</span><br><span class="line"></span><br><span class="line">    return ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;non-recursive version</span><br><span class="line">vector&lt;int&gt; preorderTraversal(TreeNode* root) &#123;</span><br><span class="line">    vector&lt;int&gt; ans;</span><br><span class="line"></span><br><span class="line">    if (root &#x3D;&#x3D; nullptr) &#123;</span><br><span class="line">        return ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    stack&lt;TreeNode*&gt; s;</span><br><span class="line"></span><br><span class="line">    while (root || !s.empty()) &#123;</span><br><span class="line">        while (root) &#123;</span><br><span class="line">            ans.push_back(root-&gt;val);</span><br><span class="line">            s.push(root);</span><br><span class="line">            root &#x3D; root -&gt; lson;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if (!s.empty()) &#123;</span><br><span class="line">            root &#x3D; s.top();</span><br><span class="line">            s.pop();</span><br><span class="line">            root &#x3D; root -&gt; rson;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; </span><br><span class="line"></span><br><span class="line">    return ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="中序遍历"><a href="#中序遍历" class="headerlink" title="中序遍历"></a>中序遍历</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;recursive version</span><br><span class="line">vector&lt;int&gt; inorderTraversal(TreeNode* root) &#123;</span><br><span class="line">    vector&lt;int&gt; ans;</span><br><span class="line"></span><br><span class="line">    if (root &#x3D;&#x3D; nullptr) &#123;</span><br><span class="line">        return ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    vector&lt;int&gt; v1 &#x3D; inorderTraversal(root-&gt;lson);</span><br><span class="line">    vector&lt;int&gt; v2 &#x3D; inorderTraversal(root-&gt;rson);</span><br><span class="line"></span><br><span class="line">    ans.insert(ans.end(), v1.begin(), v1.end());</span><br><span class="line">    ans.push_back(root-&gt;val);</span><br><span class="line">    ans.insert(ans.end(), v2.begin(), v2.end());</span><br><span class="line"></span><br><span class="line">    return ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;non-recursive version</span><br><span class="line">vector&lt;int&gt; inorderTraversal(TreeNode* root) &#123;</span><br><span class="line">    vector&lt;int&gt; ans;</span><br><span class="line"></span><br><span class="line">    if (root &#x3D;&#x3D; nullptr) &#123;</span><br><span class="line">        return ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    stack&lt;TreeNode*&gt; s;</span><br><span class="line"></span><br><span class="line">    while (root || !s.empty()) &#123;</span><br><span class="line">        while (root) &#123;</span><br><span class="line">            s.push(root);</span><br><span class="line">            root &#x3D; root -&gt; lson;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if (!s.empty()) &#123;</span><br><span class="line">            root &#x3D; s.top();</span><br><span class="line">            s.pop();</span><br><span class="line">            ans.push_back(root-&gt;val);</span><br><span class="line">            root &#x3D; root -&gt; rson;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; </span><br><span class="line"></span><br><span class="line">    return ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="后序遍历"><a href="#后序遍历" class="headerlink" title="后序遍历"></a>后序遍历</h2><p>&emsp;&emsp;前序遍历的顺序是根、左、右，而后序遍历的顺序是左、右、根。我们只需要按照前序遍历的思路实现根、右、左顺序的遍历，然后将结果反转，便能得到后序遍历的结果了。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">vector&lt;int&gt; postorderTraversal(TreeNode* root) &#123;</span><br><span class="line">    vector&lt;int&gt; ans;</span><br><span class="line"></span><br><span class="line">    if (root &#x3D;&#x3D; nullptr) &#123;</span><br><span class="line">        return ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    stack&lt;TreeNode*&gt; s;</span><br><span class="line">    </span><br><span class="line">    while (root || !s.empty()) &#123;</span><br><span class="line">        while (root) &#123;</span><br><span class="line">            ans.push_back(root-&gt;val);</span><br><span class="line">            s.push(root);</span><br><span class="line">            root &#x3D; root -&gt; rson;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if (!s.empty()) &#123;</span><br><span class="line">            root &#x3D; s.top();</span><br><span class="line">            s.pop();</span><br><span class="line">            root &#x3D; root -&gt; lson;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    reverse(ans.begin(), ans.end());</span><br><span class="line">    return ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="层序遍历"><a href="#层序遍历" class="headerlink" title="层序遍历"></a>层序遍历</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">vector&lt;int&gt; levelorderTraversal(TreeNode* root) &#123;</span><br><span class="line">    vector&lt;int&gt; ans;</span><br><span class="line"></span><br><span class="line">    if (root &#x3D;&#x3D; nullptr) &#123;</span><br><span class="line">        return ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    queue&lt;TreeNode*&gt; q;</span><br><span class="line">    q.push(root);    </span><br><span class="line"></span><br><span class="line">    while (!q.empty()) &#123;</span><br><span class="line">        TreeNode* t &#x3D; q.top();</span><br><span class="line">        q.pop();</span><br><span class="line">        ans.push_back(t-&gt;val);</span><br><span class="line"></span><br><span class="line">        if (t -&gt; lson) &#123;</span><br><span class="line">            q.push(t -&gt; lson);</span><br><span class="line">        &#125;</span><br><span class="line">        if (t -&gt; rson) &#123;</span><br><span class="line">            q.push(t -&gt; rson);</span><br><span class="line">        &#125;        </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>数据结构</category>
        <category>树</category>
      </categories>
  </entry>
  <entry>
    <title>栈</title>
    <url>/2020/11/17/stack/</url>
    <content><![CDATA[<h1 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h1><ul>
<li><h2 id="栈的定义"><a href="#栈的定义" class="headerlink" title="栈的定义"></a>栈的定义</h2>&emsp;&emsp;栈是一种<strong>后进先出</strong>的数据结构。<a id="more"></a>我们只能对栈顶进行入栈和出栈操作。</li>
</ul>
<hr>
<ul>
<li><h2 id="栈的实现"><a href="#栈的实现" class="headerlink" title="栈的实现"></a>栈的实现</h2></li>
</ul>
<ol>
<li>用数组实现栈  </li>
<li>用链表实现栈</li>
</ol>
<hr>
<ul>
<li><h2 id="栈的应用"><a href="#栈的应用" class="headerlink" title="栈的应用"></a>栈的应用</h2></li>
</ul>
<ol>
<li><h3 id="括号匹配："><a href="#括号匹配：" class="headerlink" title="括号匹配："></a>括号匹配：</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;stack&gt;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">bool isValid(const string&amp; s) &#123;</span><br><span class="line">    stack&lt;char&gt; stackOfBracket;</span><br><span class="line"></span><br><span class="line">    for (int i &#x3D; 0; i &lt; s.size(); ++i) &#123;</span><br><span class="line">        if (s[i] &#x3D;&#x3D; &#39;(&#39; || s[i] &#x3D;&#x3D; &#39;[&#39; || s[i] &#x3D;&#x3D; &#39;&#123;&#39;) &#123;</span><br><span class="line">            stackOfBracket.push(s[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        else if (s[i] &#x3D;&#x3D; &#39;)&#39;) &#123;</span><br><span class="line">            if (stackOfBracket.empty()) &#123;</span><br><span class="line">                return false;</span><br><span class="line">            &#125;</span><br><span class="line">            if (stackOfBracket.top() !&#x3D; &#39;(&#39;) &#123;</span><br><span class="line">                return false;</span><br><span class="line">            &#125;</span><br><span class="line">            stackOfBracket.pop();</span><br><span class="line">        &#125;</span><br><span class="line">        else if (s[i] &#x3D;&#x3D; &#39;]&#39;) &#123;</span><br><span class="line">            if (stackOfBracket.empty()) &#123;</span><br><span class="line">                return false;</span><br><span class="line">            &#125;</span><br><span class="line">            if (stackOfBracket.top() !&#x3D; &#39;[&#39;) &#123;</span><br><span class="line">                return false;</span><br><span class="line">            &#125;</span><br><span class="line">            stackOfBracket.pop();</span><br><span class="line">        &#125;</span><br><span class="line">        else if (s[i] &#x3D;&#x3D; &#39;&#125;&#39;) &#123;</span><br><span class="line">            if (stackOfBracket.empty()) &#123;</span><br><span class="line">                return false;</span><br><span class="line">            &#125;</span><br><span class="line">            if (stackOfBracket.top() !&#x3D; &#39;&#123;&#39;) &#123;</span><br><span class="line">                return false;</span><br><span class="line">            &#125;</span><br><span class="line">            stackOfBracket.pop();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (!stackOfBracket.empty()) &#123;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return true;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><h3 id="逆波兰式求值"><a href="#逆波兰式求值" class="headerlink" title="逆波兰式求值"></a>逆波兰式求值</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;vector&gt;</span><br><span class="line">#include &lt;string&gt;</span><br><span class="line">#include &lt;stack&gt;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">int evalRPN(const vector&lt;string&gt;&amp; expression) &#123;</span><br><span class="line">    stack&lt;int&gt; stackOfOperand;</span><br><span class="line"></span><br><span class="line">    for (int i &#x3D; 0; i &lt; expression.size(); ++i) &#123;</span><br><span class="line">        if (expression[i] &#x3D;&#x3D; &quot;+&quot;) &#123;</span><br><span class="line">            int op1 &#x3D; stackOfOperand.top();</span><br><span class="line">            stackOfOperand.pop();</span><br><span class="line">            int op2 &#x3D; stackOfOperand.top();</span><br><span class="line">            stackOfOperand.pop();</span><br><span class="line">            stackOfOperand.push(op2 + op1);</span><br><span class="line">        &#125;</span><br><span class="line">        else if (expression[i] &#x3D;&#x3D; &quot;-&quot;) &#123;</span><br><span class="line">            int op1 &#x3D; stackOfOperand.top();</span><br><span class="line">            stackOfOperand.pop();</span><br><span class="line">            int op2 &#x3D; stackOfOperand.top();</span><br><span class="line">            stackOfOperand.pop();</span><br><span class="line">            stackOfOperand.push(op2 - op1);</span><br><span class="line">        &#125;</span><br><span class="line">        else if (expression[i] &#x3D;&#x3D; &quot;*&quot;) &#123;</span><br><span class="line">            int op1 &#x3D; stackOfOperand.top();</span><br><span class="line">            stackOfOperand.pop();</span><br><span class="line">            int op2 &#x3D; stackOfOperand.top();</span><br><span class="line">            stackOfOperand.pop();</span><br><span class="line">            stackOfOperand.push(op2 * op1);</span><br><span class="line">        &#125;</span><br><span class="line">        else if (expression[i] &#x3D;&#x3D; &quot;&#x2F;&quot;) &#123;</span><br><span class="line">            int op1 &#x3D; stackOfOperand.top();</span><br><span class="line">            stackOfOperand.pop();</span><br><span class="line">            int op2 &#x3D; stackOfOperand.top();</span><br><span class="line">            stackOfOperand.pop();</span><br><span class="line">            stackOfOperand.push(op2 &#x2F; op1);</span><br><span class="line">        &#125;</span><br><span class="line">        else &#123;</span><br><span class="line">            stackOfOperand.push(stoi(expression[i]));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return stackOfOperand.top();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><h3 id="将中缀表达式转换为逆波兰式"><a href="#将中缀表达式转换为逆波兰式" class="headerlink" title="将中缀表达式转换为逆波兰式"></a>将中缀表达式转换为逆波兰式</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;vector&gt;</span><br><span class="line">#include &lt;string&gt;</span><br><span class="line">#include &lt;stack&gt;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">vector&lt;string&gt; toRPN(const string&amp; s) &#123;</span><br><span class="line">        vector&lt;string&gt; rpn;</span><br><span class="line">        stack&lt;string&gt; stackOfoperator;</span><br><span class="line"></span><br><span class="line">        for (int i &#x3D; 0; i &lt; s.size(); ++i) &#123;</span><br><span class="line">            if (s[i] &#x3D;&#x3D; &#39;+&#39;) &#123;</span><br><span class="line">                while (!stackOfoperator.empty()) &#123;</span><br><span class="line">                    rpn.push_back(stackOfoperator.top());</span><br><span class="line">                    stackOfoperator.pop();</span><br><span class="line">                &#125;</span><br><span class="line">                stackOfoperator.push(&quot;+&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">            else if (s[i] &#x3D;&#x3D; &#39;-&#39;) &#123;</span><br><span class="line">                while (!stackOfoperator.empty()) &#123;</span><br><span class="line">                    rpn.push_back(stackOfoperator.top());</span><br><span class="line">                    stackOfoperator.pop();</span><br><span class="line">                &#125;</span><br><span class="line">                stackOfoperator.push(&quot;-&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">            else if (s[i] &#x3D;&#x3D; &#39;*&#39;) &#123;</span><br><span class="line">                while (!stackOfoperator.empty() &amp;&amp; stackOfoperator.top() !&#x3D; &quot;+&quot; &amp;&amp; stackOfoperator.top() !&#x3D; &quot;-&quot;) &#123;</span><br><span class="line">                    rpn.push_back(stackOfoperator.top());</span><br><span class="line">                    stackOfoperator.pop();</span><br><span class="line">                &#125;</span><br><span class="line">                stackOfoperator.push(&quot;*&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">            else if (s[i] &#x3D;&#x3D; &#39;&#x2F;&#39;) &#123;</span><br><span class="line">                while (!stackOfoperator.empty() &amp;&amp; stackOfoperator.top() !&#x3D; &quot;+&quot; &amp;&amp; stackOfoperator.top() !&#x3D; &quot;-&quot;) &#123;</span><br><span class="line">                    rpn.push_back(stackOfoperator.top());</span><br><span class="line">                    stackOfoperator.pop();</span><br><span class="line">                &#125;</span><br><span class="line">                stackOfoperator.push(&quot;&#x2F;&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">            else &#123;</span><br><span class="line">                string nums;</span><br><span class="line">                int j &#x3D; i;</span><br><span class="line"></span><br><span class="line">                while (s[j] &gt;&#x3D; &#39;0&#39; &amp;&amp; s[j] &lt;&#x3D; &#39;9&#39;) &#123;</span><br><span class="line">                    nums.push_back(s[j++]);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                i &#x3D; j - 1;</span><br><span class="line">                rpn.push_back(nums);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        while (!stackOfoperator.empty()) &#123;</span><br><span class="line">            rpn.push_back(stackOfoperator.top());</span><br><span class="line">            stackOfoperator.pop();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return rpn;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li>
</ol>
]]></content>
      <categories>
        <category>数据结构</category>
        <category>线性结构</category>
      </categories>
  </entry>
</search>
