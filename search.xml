<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>队列</title>
    <url>/2020/11/17/queue/</url>
    <content><![CDATA[<h1 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h1><ul>
<li><h2 id="队列的定义"><a href="#队列的定义" class="headerlink" title="队列的定义"></a>队列的定义</h2>&emsp;&emsp;队列是一种<strong>先进先出的</strong>的数据结构。<a id="more"></a>我们可以对队头进行出队操作，对队尾进行入队操作。</li>
</ul>
<hr>
<ul>
<li><h2 id="队列的实现"><a href="#队列的实现" class="headerlink" title="队列的实现"></a>队列的实现</h2></li>
</ul>
<ol>
<li>用数组实现队列  </li>
<li>用链表实现队列</li>
</ol>
<hr>
<ul>
<li><h2 id="循环队列的实现"><a href="#循环队列的实现" class="headerlink" title="循环队列的实现"></a>循环队列的实现</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;vector&gt;</span><br><span class="line"></span><br><span class="line">class MyCircularQueue &#123;</span><br><span class="line">private:</span><br><span class="line">    int head, tail, size;</span><br><span class="line">    int* data;</span><br><span class="line"></span><br><span class="line">public:</span><br><span class="line">    MyCircularQueue(int size_): head(0), tail(0), size(size_+1), data(nullptr) &#123;</span><br><span class="line">        data &#x3D; new int[size];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    bool enQueue(int value) &#123;</span><br><span class="line">        if (this-&gt;isFull()) &#123;</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        data[tail] &#x3D; value;</span><br><span class="line">        ++tail;</span><br><span class="line">        tail %&#x3D; size;</span><br><span class="line">        </span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    bool deQueue() &#123;</span><br><span class="line">        if (this-&gt;isEmpty()) &#123;</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ++head;</span><br><span class="line">        head %&#x3D; size;</span><br><span class="line">        </span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    int Front() &#123;</span><br><span class="line">        if (this-&gt;isEmpty()) &#123;</span><br><span class="line">            return -1;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return data[head];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    int Rear() &#123;</span><br><span class="line">        if (this-&gt;isEmpty()) &#123;</span><br><span class="line">            return -1;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return data[(tail + size - 1) % size];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    bool isEmpty() &#123;</span><br><span class="line">        if (head &#x3D;&#x3D; tail) &#123;</span><br><span class="line">            return true;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    bool isFull() &#123;</span><br><span class="line">        if ((tail + 1) % size &#x3D;&#x3D; head) &#123;</span><br><span class="line">            return true;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ~MyCircularQueue() &#123;</span><br><span class="line">        delete []data;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
</ul>
]]></content>
      <categories>
        <category>数据结构</category>
        <category>线性结构</category>
      </categories>
  </entry>
  <entry>
    <title>二叉搜索树</title>
    <url>/2020/11/25/binary-search-tree/</url>
    <content><![CDATA[<h1 id="二叉搜索树"><a href="#二叉搜索树" class="headerlink" title="二叉搜索树"></a>二叉搜索树</h1><a id="more"></a>
<h2 id="二叉搜索树的定义"><a href="#二叉搜索树的定义" class="headerlink" title="二叉搜索树的定义"></a>二叉搜索树的定义</h2><ul>
<li>左子树所有结点的值都比根结点的值要小</li>
<li>右子树所有结点的值都比根结点的值要大</li>
<li>左、右子树都是二叉搜索树</li>
</ul>
<hr>
<h2 id="二叉搜索树的性质"><a href="#二叉搜索树的性质" class="headerlink" title="二叉搜索树的性质"></a>二叉搜索树的性质</h2><ul>
<li>二叉搜索树中序遍历的结果是严格递增的，这也可以作为二叉搜索树的一个判定条件</li>
</ul>
<hr>
<h2 id="二叉搜索树的实现"><a href="#二叉搜索树的实现" class="headerlink" title="二叉搜索树的实现"></a>二叉搜索树的实现</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">template&lt;typename elementType&gt;</span><br><span class="line">class BinarySearchTree &#123; </span><br><span class="line">private:</span><br><span class="line">    &#x2F;&#x2F;结点的定义</span><br><span class="line">    struct TreeNode &#123;</span><br><span class="line">        elementType val;</span><br><span class="line">        TreeNode *lson, *rson;</span><br><span class="line"></span><br><span class="line">        TreeNode(elementType val_, TreeNode *lson_ &#x3D; nullptr, TreeNode *rson_ &#x3D; nullptr): val(val_), lson(lson_), rson(rson_) &#123;&#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">     &#x2F;&#x2F;根结点</span><br><span class="line">    TreeNode *root;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;将以该结点为根结点的树清空</span><br><span class="line">    void makeEmpty(TreeNode* root) &#123;</span><br><span class="line">        if (root &#x3D;&#x3D; nullptr) &#123;</span><br><span class="line">            return ;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        makeEmpty(root-&gt;lson);</span><br><span class="line">        makeEmpty(root-&gt;rson);</span><br><span class="line">        delete root;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    bool remove(elementType val, TreeNode *&amp;root) &#123;</span><br><span class="line">        if (root &#x3D;&#x3D; nullptr) &#123;</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if (val &lt; root-&gt;val) &#123;</span><br><span class="line">            return remove(val, root-&gt;lson);</span><br><span class="line">        &#125;</span><br><span class="line">        else if (val &gt; root-&gt;val) &#123;</span><br><span class="line">            return remove(val, root-&gt;rson);</span><br><span class="line">        &#125;</span><br><span class="line">        else &#123;</span><br><span class="line">            &#x2F;&#x2F;有两个儿子</span><br><span class="line">            if (root-&gt;lson &amp;&amp; root-&gt;rson) &#123;</span><br><span class="line">                root-&gt;val &#x3D; findMin(root-&gt;rson)-&gt;val;</span><br><span class="line">                remove(root-&gt;val, root-&gt;rson);</span><br><span class="line">            &#125;</span><br><span class="line">            &#x2F;&#x2F;少于两个儿子</span><br><span class="line">            else &#123;</span><br><span class="line">                TreeNode *t &#x3D; root;</span><br><span class="line">                root &#x3D; (root-&gt;lson &#x3D;&#x3D; nullptr) ? (root-&gt;rson) : (root-&gt;lson);</span><br><span class="line">                delete t;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">public:</span><br><span class="line">    &#x2F;&#x2F;构造函数</span><br><span class="line">    BinarySearchTree(): root(nullptr) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;析构函数</span><br><span class="line">    ~BinarySearchTree() &#123;</span><br><span class="line">        makeEmpty(root);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;查找函数</span><br><span class="line">    bool find(elementType val) const &#123;</span><br><span class="line">        TreeNode* curRoot &#x3D; root;</span><br><span class="line">        while (curRoot) &#123;</span><br><span class="line">            if (val &lt; curRoot-&gt;val) &#123;</span><br><span class="line">                curRoot &#x3D; curRoot -&gt; lson;</span><br><span class="line">            &#125;</span><br><span class="line">            else if (val &gt; curRoot-&gt;val) &#123;</span><br><span class="line">                curRoot &#x3D; curRoot -&gt; rson;</span><br><span class="line">            &#125;</span><br><span class="line">            else &#123;</span><br><span class="line">                return true;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">    TreeNode* findMin() const &#123;</span><br><span class="line">        if (root &#x3D;&#x3D; nullptr) &#123;</span><br><span class="line">            return root;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        TreeNode *minNode &#x3D; root;</span><br><span class="line">        while (minNode -&gt; lson) &#123;</span><br><span class="line">            minNode &#x3D; minNode -&gt; lson;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return minNode;</span><br><span class="line">    &#125;</span><br><span class="line">    TreeNode* findMax() const &#123;</span><br><span class="line">        if (root &#x3D;&#x3D; nullptr) &#123;</span><br><span class="line">            return root;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        TreeNode *maxNode &#x3D; root;</span><br><span class="line">        while (maxNode -&gt; rson) &#123;</span><br><span class="line">            maxNode &#x3D; maxNode -&gt; rson;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return maxNode;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;修改函数</span><br><span class="line">    &#x2F;&#x2F;插入一个新结点</span><br><span class="line">    bool insert(elementType val) &#123;</span><br><span class="line">        if (this-&gt;contains(val)) &#123;</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if (root &#x3D;&#x3D; nullptr) &#123;</span><br><span class="line">            root &#x3D; new TreeNode(val);</span><br><span class="line">            return true;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        TreeNode *preNode &#x3D; root;</span><br><span class="line">        while (1) &#123;</span><br><span class="line">            if (val &lt; preNode-&gt;val) &#123;</span><br><span class="line">                if (preNode-&gt;lson &#x3D;&#x3D; nullptr) &#123;</span><br><span class="line">                    preNode-&gt;lson &#x3D; new TreeNode(val);</span><br><span class="line">                    return true;</span><br><span class="line">                &#125;</span><br><span class="line">                else &#123;</span><br><span class="line">                    preNode &#x3D; preNode -&gt; lson;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            if (val &gt; preNode-&gt;val) &#123;</span><br><span class="line">                if (preNode-&gt;rson &#x3D;&#x3D; nullptr) &#123;</span><br><span class="line">                    preNode-&gt;rson &#x3D; new TreeNode(val);</span><br><span class="line">                    return true;</span><br><span class="line">                &#125;</span><br><span class="line">                else &#123;</span><br><span class="line">                    preNode &#x3D; preNode -&gt; rson;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">    bool remove(elementType val) &#123;</span><br><span class="line">        return remove(val, root);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>数据结构</category>
        <category>树</category>
      </categories>
  </entry>
  <entry>
    <title>栈</title>
    <url>/2020/11/17/stack/</url>
    <content><![CDATA[<h1 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h1><ul>
<li><h2 id="栈的定义"><a href="#栈的定义" class="headerlink" title="栈的定义"></a>栈的定义</h2>&emsp;&emsp;栈是一种<strong>后进先出</strong>的数据结构。<a id="more"></a>我们只能对栈顶进行入栈和出栈操作。</li>
</ul>
<hr>
<ul>
<li><h2 id="栈的实现"><a href="#栈的实现" class="headerlink" title="栈的实现"></a>栈的实现</h2></li>
</ul>
<ol>
<li>用数组实现栈  </li>
<li>用链表实现栈</li>
</ol>
<hr>
<ul>
<li><h2 id="栈的应用"><a href="#栈的应用" class="headerlink" title="栈的应用"></a>栈的应用</h2></li>
</ul>
<ol>
<li><h3 id="括号匹配："><a href="#括号匹配：" class="headerlink" title="括号匹配："></a>括号匹配：</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;stack&gt;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">bool isValid(const string&amp; s) &#123;</span><br><span class="line">    stack&lt;char&gt; stackOfBracket;</span><br><span class="line"></span><br><span class="line">    for (int i &#x3D; 0; i &lt; s.size(); ++i) &#123;</span><br><span class="line">        if (s[i] &#x3D;&#x3D; &#39;(&#39; || s[i] &#x3D;&#x3D; &#39;[&#39; || s[i] &#x3D;&#x3D; &#39;&#123;&#39;) &#123;</span><br><span class="line">            stackOfBracket.push(s[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        else if (s[i] &#x3D;&#x3D; &#39;)&#39;) &#123;</span><br><span class="line">            if (stackOfBracket.empty()) &#123;</span><br><span class="line">                return false;</span><br><span class="line">            &#125;</span><br><span class="line">            if (stackOfBracket.top() !&#x3D; &#39;(&#39;) &#123;</span><br><span class="line">                return false;</span><br><span class="line">            &#125;</span><br><span class="line">            stackOfBracket.pop();</span><br><span class="line">        &#125;</span><br><span class="line">        else if (s[i] &#x3D;&#x3D; &#39;]&#39;) &#123;</span><br><span class="line">            if (stackOfBracket.empty()) &#123;</span><br><span class="line">                return false;</span><br><span class="line">            &#125;</span><br><span class="line">            if (stackOfBracket.top() !&#x3D; &#39;[&#39;) &#123;</span><br><span class="line">                return false;</span><br><span class="line">            &#125;</span><br><span class="line">            stackOfBracket.pop();</span><br><span class="line">        &#125;</span><br><span class="line">        else if (s[i] &#x3D;&#x3D; &#39;&#125;&#39;) &#123;</span><br><span class="line">            if (stackOfBracket.empty()) &#123;</span><br><span class="line">                return false;</span><br><span class="line">            &#125;</span><br><span class="line">            if (stackOfBracket.top() !&#x3D; &#39;&#123;&#39;) &#123;</span><br><span class="line">                return false;</span><br><span class="line">            &#125;</span><br><span class="line">            stackOfBracket.pop();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (!stackOfBracket.empty()) &#123;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return true;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><h3 id="逆波兰式求值"><a href="#逆波兰式求值" class="headerlink" title="逆波兰式求值"></a>逆波兰式求值</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;vector&gt;</span><br><span class="line">#include &lt;string&gt;</span><br><span class="line">#include &lt;stack&gt;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">int evalRPN(const vector&lt;string&gt;&amp; expression) &#123;</span><br><span class="line">    stack&lt;int&gt; stackOfOperand;</span><br><span class="line"></span><br><span class="line">    for (int i &#x3D; 0; i &lt; expression.size(); ++i) &#123;</span><br><span class="line">        if (expression[i] &#x3D;&#x3D; &quot;+&quot;) &#123;</span><br><span class="line">            int op1 &#x3D; stackOfOperand.top();</span><br><span class="line">            stackOfOperand.pop();</span><br><span class="line">            int op2 &#x3D; stackOfOperand.top();</span><br><span class="line">            stackOfOperand.pop();</span><br><span class="line">            stackOfOperand.push(op2 + op1);</span><br><span class="line">        &#125;</span><br><span class="line">        else if (expression[i] &#x3D;&#x3D; &quot;-&quot;) &#123;</span><br><span class="line">            int op1 &#x3D; stackOfOperand.top();</span><br><span class="line">            stackOfOperand.pop();</span><br><span class="line">            int op2 &#x3D; stackOfOperand.top();</span><br><span class="line">            stackOfOperand.pop();</span><br><span class="line">            stackOfOperand.push(op2 - op1);</span><br><span class="line">        &#125;</span><br><span class="line">        else if (expression[i] &#x3D;&#x3D; &quot;*&quot;) &#123;</span><br><span class="line">            int op1 &#x3D; stackOfOperand.top();</span><br><span class="line">            stackOfOperand.pop();</span><br><span class="line">            int op2 &#x3D; stackOfOperand.top();</span><br><span class="line">            stackOfOperand.pop();</span><br><span class="line">            stackOfOperand.push(op2 * op1);</span><br><span class="line">        &#125;</span><br><span class="line">        else if (expression[i] &#x3D;&#x3D; &quot;&#x2F;&quot;) &#123;</span><br><span class="line">            int op1 &#x3D; stackOfOperand.top();</span><br><span class="line">            stackOfOperand.pop();</span><br><span class="line">            int op2 &#x3D; stackOfOperand.top();</span><br><span class="line">            stackOfOperand.pop();</span><br><span class="line">            stackOfOperand.push(op2 &#x2F; op1);</span><br><span class="line">        &#125;</span><br><span class="line">        else &#123;</span><br><span class="line">            stackOfOperand.push(stoi(expression[i]));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return stackOfOperand.top();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><h3 id="将中缀表达式转换为逆波兰式"><a href="#将中缀表达式转换为逆波兰式" class="headerlink" title="将中缀表达式转换为逆波兰式"></a>将中缀表达式转换为逆波兰式</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;vector&gt;</span><br><span class="line">#include &lt;string&gt;</span><br><span class="line">#include &lt;stack&gt;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">vector&lt;string&gt; toRPN(const string&amp; s) &#123;</span><br><span class="line">        vector&lt;string&gt; rpn;</span><br><span class="line">        stack&lt;string&gt; stackOfoperator;</span><br><span class="line"></span><br><span class="line">        for (int i &#x3D; 0; i &lt; s.size(); ++i) &#123;</span><br><span class="line">            if (s[i] &#x3D;&#x3D; &#39;+&#39;) &#123;</span><br><span class="line">                while (!stackOfoperator.empty()) &#123;</span><br><span class="line">                    rpn.push_back(stackOfoperator.top());</span><br><span class="line">                    stackOfoperator.pop();</span><br><span class="line">                &#125;</span><br><span class="line">                stackOfoperator.push(&quot;+&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">            else if (s[i] &#x3D;&#x3D; &#39;-&#39;) &#123;</span><br><span class="line">                while (!stackOfoperator.empty()) &#123;</span><br><span class="line">                    rpn.push_back(stackOfoperator.top());</span><br><span class="line">                    stackOfoperator.pop();</span><br><span class="line">                &#125;</span><br><span class="line">                stackOfoperator.push(&quot;-&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">            else if (s[i] &#x3D;&#x3D; &#39;*&#39;) &#123;</span><br><span class="line">                while (!stackOfoperator.empty() &amp;&amp; stackOfoperator.top() !&#x3D; &quot;+&quot; &amp;&amp; stackOfoperator.top() !&#x3D; &quot;-&quot;) &#123;</span><br><span class="line">                    rpn.push_back(stackOfoperator.top());</span><br><span class="line">                    stackOfoperator.pop();</span><br><span class="line">                &#125;</span><br><span class="line">                stackOfoperator.push(&quot;*&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">            else if (s[i] &#x3D;&#x3D; &#39;&#x2F;&#39;) &#123;</span><br><span class="line">                while (!stackOfoperator.empty() &amp;&amp; stackOfoperator.top() !&#x3D; &quot;+&quot; &amp;&amp; stackOfoperator.top() !&#x3D; &quot;-&quot;) &#123;</span><br><span class="line">                    rpn.push_back(stackOfoperator.top());</span><br><span class="line">                    stackOfoperator.pop();</span><br><span class="line">                &#125;</span><br><span class="line">                stackOfoperator.push(&quot;&#x2F;&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">            else &#123;</span><br><span class="line">                string nums;</span><br><span class="line">                int j &#x3D; i;</span><br><span class="line"></span><br><span class="line">                while (s[j] &gt;&#x3D; &#39;0&#39; &amp;&amp; s[j] &lt;&#x3D; &#39;9&#39;) &#123;</span><br><span class="line">                    nums.push_back(s[j++]);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                i &#x3D; j - 1;</span><br><span class="line">                rpn.push_back(nums);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        while (!stackOfoperator.empty()) &#123;</span><br><span class="line">            rpn.push_back(stackOfoperator.top());</span><br><span class="line">            stackOfoperator.pop();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return rpn;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li>
</ol>
]]></content>
      <categories>
        <category>数据结构</category>
        <category>线性结构</category>
      </categories>
  </entry>
  <entry>
    <title>优先队列（堆）</title>
    <url>/2020/12/22/heap/</url>
    <content><![CDATA[<h1 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h1><a id="more"></a>
<h2 id="堆的性质"><a href="#堆的性质" class="headerlink" title="堆的性质"></a>堆的性质</h2><ul>
<li>结构性质<br>&emsp;&emsp;堆是由<strong>完全二叉树</strong>构成的。完全二叉树是指如二叉树的高度为h，除h层外，其他各层（1到h-1层）的结点个数都达到最大，第h层的结点都连续集中分布在最左边。例如：<img src="/.io//photo1.png" style="zoom: 67%;">
&emsp;&emsp;我们可以利用这个性质来构建堆。通过观察我们可以发现对于结点x，它的父亲结点为x/2（若存在），它的左右儿子结点分别为2x，2x+1（若存在）。因此，可以用数组来模拟堆。</li>
<li>堆序性质<br>&emsp;&emsp;在一个小根堆中，对于每一个结点X，X关键字总小于等于X的儿子的关键字。</li>
</ul>
<hr>
<h2 id="基本操作的实现"><a href="#基本操作的实现" class="headerlink" title="基本操作的实现"></a>基本操作的实现</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;utility&gt;</span><br><span class="line">&#x2F;&#x2F;此处实现大根堆，小根堆实现方法类似</span><br><span class="line">template&lt;typename elemType&gt;</span><br><span class="line">class heap &#123;</span><br><span class="line">public:</span><br><span class="line">    &#x2F;&#x2F;构造函数</span><br><span class="line">    heap(int capacity_);</span><br><span class="line">    &#x2F;&#x2F;建堆</span><br><span class="line">    heap(const vector&lt;elemType&gt;&amp; data_);</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;析构函数</span><br><span class="line">    ~heap();</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;压入与弹出</span><br><span class="line">    void push(elemType newVal);</span><br><span class="line">    void pop();</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;查看堆</span><br><span class="line">    elemType getTop() const;</span><br><span class="line">    bool empty() const;</span><br><span class="line">    int getSize() const; </span><br><span class="line">private:</span><br><span class="line">    int capacity, size;</span><br><span class="line">    elemType* data; </span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;下滤</span><br><span class="line">    void down(int index);</span><br><span class="line">    &#x2F;&#x2F;上滤</span><br><span class="line">    void up(int index);</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;改变存储数据的数组容量</span><br><span class="line">    void reserve(int newCapacity);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">template&lt;typename elemType&gt;</span><br><span class="line">heap&lt;elemType&gt;::heap(int capacity_): capacity(capacity_+1), size(0), data(nullptr) &#123;</span><br><span class="line">    data &#x3D; new elemType[capacity];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">template&lt;typename elemType&gt;</span><br><span class="line">heap&lt;elemType&gt;::heap(const vector&lt;elemType&gt;&amp; data_): capacity(data_.size()+1), size(capacity-1), data(nullptr) &#123;</span><br><span class="line">    data &#x3D; new elemType[capacity];</span><br><span class="line"></span><br><span class="line">    for (int i &#x3D; 1; i &lt;&#x3D; size; ++i) &#123;</span><br><span class="line">        data[i] &#x3D; data_[i-1];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;自底向上将堆中的非叶节点维护为堆</span><br><span class="line">    for (int i &#x3D; size&#x2F;2; i &gt; 0; --i) &#123;</span><br><span class="line">        down(i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">template&lt;typename elemType&gt;</span><br><span class="line">heap&lt;elemType&gt;::~heap() &#123;</span><br><span class="line">    if (data) &#123;</span><br><span class="line">        delete[] data;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">template&lt;typename elemType&gt;</span><br><span class="line">void heap&lt;elemType&gt;::push(elemType newVal) &#123;</span><br><span class="line">    if (size &#x3D;&#x3D; capacity-1) &#123;</span><br><span class="line">        this-&gt;reserve(capacity * 2);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ++size;</span><br><span class="line">    data[size] &#x3D; newVal;</span><br><span class="line">    up(size);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">template&lt;typename elemType&gt;</span><br><span class="line">void heap&lt;elemType&gt;::pop() &#123;</span><br><span class="line">    if (size &#x3D;&#x3D; 0) &#123;</span><br><span class="line">        return ;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    data[1] &#x3D; data[size];</span><br><span class="line">    --size;</span><br><span class="line">    down(1);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">template&lt;typename elemType&gt;</span><br><span class="line">elemType heap&lt;elemType&gt;::getTop() const &#123;</span><br><span class="line">    return data[1];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">template&lt;typename elemType&gt;</span><br><span class="line">bool heap&lt;elemType&gt;::empty() const &#123;</span><br><span class="line">    return (size &#x3D;&#x3D; 0);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">template&lt;typename elemType&gt;</span><br><span class="line">int heap&lt;elemType&gt;::getSize() const &#123;</span><br><span class="line">    return size;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">template&lt;typename elemType&gt;</span><br><span class="line">void heap&lt;elemType&gt;::down(int index) &#123;</span><br><span class="line">    elemType t &#x3D; data[index];</span><br><span class="line"></span><br><span class="line">    while (index &lt;&#x3D; size&#x2F;2) &#123;</span><br><span class="line">        int maxSon &#x3D; index*2;</span><br><span class="line">        if (maxSon+1 &lt;&#x3D; size &amp;&amp; data[maxSon+1] &gt; data[maxSon]) &#123;</span><br><span class="line">            ++maxSon;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if (data[maxSon] &lt;&#x3D; t) &#123;</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        data[index] &#x3D; std::move(data[maxSon]);</span><br><span class="line">        index &#x3D; maxSon;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    data[index] &#x3D; t;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">template&lt;typename elemType&gt;</span><br><span class="line">void heap&lt;elemType&gt;::up(int index) &#123;</span><br><span class="line">    int t &#x3D; data[index];</span><br><span class="line"></span><br><span class="line">    while (index &gt; 1) &#123;</span><br><span class="line">        if (t &lt;&#x3D; data[index&#x2F;2]) &#123;</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        data[index] &#x3D; std::move(data[index&#x2F;2]);</span><br><span class="line">        index &#x2F;&#x3D; 2;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    data[index] &#x3D; t;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">template&lt;typename elemType&gt;</span><br><span class="line">void heap&lt;elemType&gt;::reserve(int newCapacity) &#123;</span><br><span class="line">    elemType* t &#x3D; data;</span><br><span class="line">    data &#x3D; new elemType[newCapacity];</span><br><span class="line"></span><br><span class="line">    for (int i &#x3D; 1; i &lt;&#x3D; size; ++i) &#123;</span><br><span class="line">        data[i] &#x3D; t[i];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    delete[] t;</span><br><span class="line">    capacity &#x3D; newCapacity;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>数据结构</category>
        <category>堆</category>
      </categories>
  </entry>
  <entry>
    <title>排序</title>
    <url>/2020/12/24/sort/</url>
    <content><![CDATA[<h1 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h1><a id="more"></a>
<p>&emsp;&emsp;本篇博客提供几种常见排序算法的实现。若无特别说明，本篇博客的所有程序采取非降序排列。</p>
<h2 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">template&lt;typename elemType&gt;</span><br><span class="line">void insertionSort(vector&lt;elemType&gt; &amp;v) &#123;</span><br><span class="line">    &#x2F;&#x2F;插入第i+1个元素</span><br><span class="line">    for (int i &#x3D; 1; i &lt; v.size(); ++i) &#123;</span><br><span class="line">        &#x2F;&#x2F;找到第一个小于等于v[i]的元素</span><br><span class="line">        int t &#x3D; v[i], j;</span><br><span class="line">        for (j &#x3D; i; j &gt; 0 &amp;&amp; t &lt; v[j-1]; --j) &#123;</span><br><span class="line">            v[j] &#x3D; v[j-1];</span><br><span class="line">        &#125;</span><br><span class="line">        v[j] &#x3D; t;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="希尔排序"><a href="#希尔排序" class="headerlink" title="希尔排序"></a>希尔排序</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">template&lt;typename elemType&gt;</span><br><span class="line">void shellSort(vector&lt;elemType&gt; &amp;v, const vector&lt;int&gt;&amp; h) &#123;</span><br><span class="line">    &#x2F;&#x2F;使数组变为gap有序的</span><br><span class="line">    for (int gap : h) &#123;</span><br><span class="line">        &#x2F;&#x2F;进行一次插入排序</span><br><span class="line">        for (int i &#x3D; gap; i &lt; v.size(); ++i) &#123;</span><br><span class="line">            int t &#x3D; v[i], j;</span><br><span class="line">            for (j &#x3D; i; j &gt;&#x3D; gap &amp;&amp; t &lt; v[j-gap]; j-&#x3D;gap) &#123;</span><br><span class="line">                v[j] &#x3D; v[j-gap];</span><br><span class="line">            &#125;</span><br><span class="line">            v[j] &#x3D; t;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">template&lt;typename elemType&gt;</span><br><span class="line">void down(vector&lt;elemType&gt;&amp; v, int n, int index) &#123;</span><br><span class="line">    while (2*index+1 &lt; n) &#123;</span><br><span class="line">        int maxSon &#x3D; 2 * index + 1;</span><br><span class="line">        if (maxSon+1 &lt; n &amp;&amp; v[maxSon+1] &gt; v[maxSon]) &#123;</span><br><span class="line">            ++maxSon;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if (v[index] &gt;&#x3D; v[maxSon]) &#123;</span><br><span class="line">            return ;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        swap(v[index], v[maxSon]);</span><br><span class="line">        index &#x3D; maxSon;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">template&lt;typename elemType&gt;</span><br><span class="line">void heapSort(vector&lt;elemType&gt;&amp; v) &#123;</span><br><span class="line">    int n &#x3D; v.size();</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;建堆</span><br><span class="line">    for (int i &#x3D; (n-2)&#x2F;2; i &gt;&#x3D; 0; --i) &#123;</span><br><span class="line">        down(v, n, i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;排序</span><br><span class="line">    for (int i &#x3D; n-1; i &gt; 0; --i) &#123;</span><br><span class="line">        swap(v[i], v[0]);</span><br><span class="line">        down(v, i, 0);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">template&lt;typename elemType&gt;</span><br><span class="line">void merge(vector&lt;elemType&gt;&amp; v, vector&lt;elemType&gt;&amp; t, int l, int m, int r) &#123;</span><br><span class="line">    int ctr1 &#x3D; l, ctr2 &#x3D; m+1, ctr3 &#x3D; l;</span><br><span class="line"></span><br><span class="line">    while (ctr1 &lt;&#x3D; m &amp;&amp; ctr2 &lt;&#x3D; r) &#123;</span><br><span class="line">        if (v[ctr1] &lt; v[ctr2]) &#123;</span><br><span class="line">            t[ctr3++] &#x3D; v[ctr1++];</span><br><span class="line">        &#125;</span><br><span class="line">        else &#123;</span><br><span class="line">            t[ctr3++] &#x3D; v[ctr2++];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    while (ctr1 &lt;&#x3D; m) &#123;</span><br><span class="line">        t[ctr3++] &#x3D; v[ctr1++];</span><br><span class="line">    &#125;</span><br><span class="line">    while (ctr2 &lt;&#x3D; r) &#123;</span><br><span class="line">        t[ctr3++] &#x3D; v[ctr2++];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    for (int i &#x3D; l; i &lt;&#x3D; r; ++i) &#123;</span><br><span class="line">        v[i] &#x3D; t[i];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">template&lt;typename elemType&gt;</span><br><span class="line">void mergeSort(vector&lt;elemType&gt;&amp; v, vector&lt;elemType&gt;&amp; t,int l, int r) &#123;</span><br><span class="line">    if (l &lt; r) &#123;</span><br><span class="line">        int m &#x3D; l + (r - l) &#x2F; 2;</span><br><span class="line"></span><br><span class="line">        mergeSort(v, t, l, m);</span><br><span class="line">        mergeSort(v, t, m+1, r);</span><br><span class="line"></span><br><span class="line">        merge(v, t, l, m, r);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">template&lt;typename elemType&gt;</span><br><span class="line">void mergeSort(vector&lt;elemType&gt;&amp; v) &#123;</span><br><span class="line">    &#x2F;&#x2F;减少活动vector数量</span><br><span class="line">    vector&lt;elemType&gt; t(v.size());</span><br><span class="line">    &#x2F;&#x2F;统一接口</span><br><span class="line">    mergeSort(v, t, 0, v.size()-1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">template&lt;typename elemType&gt;</span><br><span class="line">void insertionSort(vector&lt;elemType&gt; &amp;v, int l, int r) &#123;</span><br><span class="line">    &#x2F;&#x2F;插入第i+1个元素</span><br><span class="line">    for (int i &#x3D; l+1; i &lt;&#x3D; r; ++i) &#123;</span><br><span class="line">        &#x2F;&#x2F;找到第一个小于等于v[i]的元素</span><br><span class="line">        int t &#x3D; v[i], j;</span><br><span class="line">        for (j &#x3D; i; j &gt; l &amp;&amp; t &lt; v[j-1]; --j) &#123;</span><br><span class="line">            v[j] &#x3D; v[j-1];</span><br><span class="line">        &#125;</span><br><span class="line">        v[j] &#x3D; t;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">template&lt;typename elemType&gt;</span><br><span class="line">elemType getMid3(vector&lt;elemType&gt;&amp; v, int l, int r) &#123;</span><br><span class="line">    int m &#x3D; l + (r - l) &#x2F; 2;</span><br><span class="line"></span><br><span class="line">    if (v[m] &lt; v[l]) &#123;</span><br><span class="line">        swap(v[m], v[l]);</span><br><span class="line">    &#125;</span><br><span class="line">    if (v[r] &lt; v[l]) &#123;</span><br><span class="line">        swap(v[r], v[l]);</span><br><span class="line">    &#125;</span><br><span class="line">    if (v[m] &lt; v[r]) &#123;</span><br><span class="line">        swap(v[r], v[m]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    swap(v[m], v[r-1]);</span><br><span class="line"></span><br><span class="line">    return v[r];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">template&lt;typename elemType&gt;</span><br><span class="line">void quickSort(vector&lt;elemType&gt;&amp; v, int l, int r) &#123;</span><br><span class="line">    if (r - l + 1 &gt;&#x3D; 10) &#123;</span><br><span class="line">        &#x2F;&#x2F;选取枢纽元</span><br><span class="line">        auto pivot &#x3D; getMid3(v, l, r);</span><br><span class="line"></span><br><span class="line">        int i &#x3D; l, j &#x3D; r-1;</span><br><span class="line"></span><br><span class="line">        while (1) &#123;</span><br><span class="line">            while (v[++i] &lt; pivot) &#123;&#125;</span><br><span class="line">            while (v[--j] &gt; pivot) &#123;&#125;</span><br><span class="line"></span><br><span class="line">            if (i &lt; j) &#123;</span><br><span class="line">                swap(v[i], v[j]);</span><br><span class="line">            &#125;</span><br><span class="line">            else &#123;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        swap(v[i], v[r]);</span><br><span class="line">        quickSort(v, l, i-1);</span><br><span class="line">        quickSort(v, i+1, r);</span><br><span class="line">    &#125;</span><br><span class="line">    else &#123;</span><br><span class="line">        insertionSort(v, l , r);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">template&lt;typename elemType&gt;</span><br><span class="line">void quickSort(vector&lt;elemType&gt;&amp; v) &#123;</span><br><span class="line">    &#x2F;&#x2F;统一接口</span><br><span class="line">    quickSort(v, 0, v.size()-1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>算法</category>
        <category>排序</category>
      </categories>
  </entry>
  <entry>
    <title>树的遍历</title>
    <url>/2020/11/26/traversal/</url>
    <content><![CDATA[<h1 id="树的遍历"><a href="#树的遍历" class="headerlink" title="树的遍历"></a>树的遍历</h1><a id="more"></a>

<p>&emsp;&emsp;树的遍历一共分为4种，分别为前序遍历、中序遍历、后序遍历和层序遍历。本文仅针对二叉树讲讲这四种遍历方式。</p>
<hr>
<p>&emsp;&emsp;树结点的定义为：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">struct TreeNode &#123;</span><br><span class="line">    elementType val;</span><br><span class="line">    TreeNode *lson, *rson;</span><br><span class="line"></span><br><span class="line">    TreeNode(elementType val_, TreeNode *lson_ &#x3D; nullptr, TreeNode *rson_ &#x3D; nullptr): val(val_), lson(lson_), rson(rson_) &#123;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="前序遍历"><a href="#前序遍历" class="headerlink" title="前序遍历"></a>前序遍历</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;recursive version</span><br><span class="line">vector&lt;int&gt; preorderTraversal(TreeNode* root) &#123;</span><br><span class="line">    vector&lt;int&gt; ans;</span><br><span class="line"></span><br><span class="line">    if (root &#x3D;&#x3D; nullptr) &#123;</span><br><span class="line">        return ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    vector&lt;int&gt; v1 &#x3D; preorderTraversal(root-&gt;lson);</span><br><span class="line">    vector&lt;int&gt; v2 &#x3D; preorderTraversal(root-&gt;rson);</span><br><span class="line"></span><br><span class="line">    ans.push_back(root-&gt;val);</span><br><span class="line">    ans.insert(ans.end(), v1.begin(), v1.end());</span><br><span class="line">    ans.insert(ans.end(), v2.begin(), v2.end());</span><br><span class="line"></span><br><span class="line">    return ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;non-recursive version</span><br><span class="line">vector&lt;int&gt; preorderTraversal(TreeNode* root) &#123;</span><br><span class="line">    vector&lt;int&gt; ans;</span><br><span class="line"></span><br><span class="line">    if (root &#x3D;&#x3D; nullptr) &#123;</span><br><span class="line">        return ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    stack&lt;TreeNode*&gt; s;</span><br><span class="line"></span><br><span class="line">    while (root || !s.empty()) &#123;</span><br><span class="line">        while (root) &#123;</span><br><span class="line">            ans.push_back(root-&gt;val);</span><br><span class="line">            s.push(root);</span><br><span class="line">            root &#x3D; root -&gt; lson;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if (!s.empty()) &#123;</span><br><span class="line">            root &#x3D; s.top();</span><br><span class="line">            s.pop();</span><br><span class="line">            root &#x3D; root -&gt; rson;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; </span><br><span class="line"></span><br><span class="line">    return ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="中序遍历"><a href="#中序遍历" class="headerlink" title="中序遍历"></a>中序遍历</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;recursive version</span><br><span class="line">vector&lt;int&gt; inorderTraversal(TreeNode* root) &#123;</span><br><span class="line">    vector&lt;int&gt; ans;</span><br><span class="line"></span><br><span class="line">    if (root &#x3D;&#x3D; nullptr) &#123;</span><br><span class="line">        return ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    vector&lt;int&gt; v1 &#x3D; inorderTraversal(root-&gt;lson);</span><br><span class="line">    vector&lt;int&gt; v2 &#x3D; inorderTraversal(root-&gt;rson);</span><br><span class="line"></span><br><span class="line">    ans.insert(ans.end(), v1.begin(), v1.end());</span><br><span class="line">    ans.push_back(root-&gt;val);</span><br><span class="line">    ans.insert(ans.end(), v2.begin(), v2.end());</span><br><span class="line"></span><br><span class="line">    return ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;non-recursive version</span><br><span class="line">vector&lt;int&gt; inorderTraversal(TreeNode* root) &#123;</span><br><span class="line">    vector&lt;int&gt; ans;</span><br><span class="line"></span><br><span class="line">    if (root &#x3D;&#x3D; nullptr) &#123;</span><br><span class="line">        return ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    stack&lt;TreeNode*&gt; s;</span><br><span class="line"></span><br><span class="line">    while (root || !s.empty()) &#123;</span><br><span class="line">        while (root) &#123;</span><br><span class="line">            s.push(root);</span><br><span class="line">            root &#x3D; root -&gt; lson;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if (!s.empty()) &#123;</span><br><span class="line">            root &#x3D; s.top();</span><br><span class="line">            s.pop();</span><br><span class="line">            ans.push_back(root-&gt;val);</span><br><span class="line">            root &#x3D; root -&gt; rson;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; </span><br><span class="line"></span><br><span class="line">    return ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="后序遍历"><a href="#后序遍历" class="headerlink" title="后序遍历"></a>后序遍历</h2><p>&emsp;&emsp;前序遍历的顺序是根、左、右，而后序遍历的顺序是左、右、根。我们只需要按照前序遍历的思路实现根、右、左顺序的遍历，然后将结果反转，便能得到后序遍历的结果了。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">vector&lt;int&gt; postorderTraversal(TreeNode* root) &#123;</span><br><span class="line">    vector&lt;int&gt; ans;</span><br><span class="line"></span><br><span class="line">    if (root &#x3D;&#x3D; nullptr) &#123;</span><br><span class="line">        return ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    stack&lt;TreeNode*&gt; s;</span><br><span class="line">    </span><br><span class="line">    while (root || !s.empty()) &#123;</span><br><span class="line">        while (root) &#123;</span><br><span class="line">            ans.push_back(root-&gt;val);</span><br><span class="line">            s.push(root);</span><br><span class="line">            root &#x3D; root -&gt; rson;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if (!s.empty()) &#123;</span><br><span class="line">            root &#x3D; s.top();</span><br><span class="line">            s.pop();</span><br><span class="line">            root &#x3D; root -&gt; lson;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    reverse(ans.begin(), ans.end());</span><br><span class="line">    return ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="层序遍历"><a href="#层序遍历" class="headerlink" title="层序遍历"></a>层序遍历</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">vector&lt;int&gt; levelorderTraversal(TreeNode* root) &#123;</span><br><span class="line">    vector&lt;int&gt; ans;</span><br><span class="line"></span><br><span class="line">    if (root &#x3D;&#x3D; nullptr) &#123;</span><br><span class="line">        return ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    queue&lt;TreeNode*&gt; q;</span><br><span class="line">    q.push(root);    </span><br><span class="line"></span><br><span class="line">    while (!q.empty()) &#123;</span><br><span class="line">        TreeNode* t &#x3D; q.top();</span><br><span class="line">        q.pop();</span><br><span class="line">        ans.push_back(t-&gt;val);</span><br><span class="line"></span><br><span class="line">        if (t -&gt; lson) &#123;</span><br><span class="line">            q.push(t -&gt; lson);</span><br><span class="line">        &#125;</span><br><span class="line">        if (t -&gt; rson) &#123;</span><br><span class="line">            q.push(t -&gt; rson);</span><br><span class="line">        &#125;        </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h1 id="利用遍历结构还原树"><a href="#利用遍历结构还原树" class="headerlink" title="利用遍历结构还原树"></a>利用遍历结构还原树</h1><p>&emsp;&emsp;知道了二叉树的遍历结果，我们可以利用遍历的结果来还原一颗树。但是至少需要知道两种不同遍历方式的结果，并且其中一种为中序遍历。</p>
<h2 id="知道前序遍历和中序遍历构建二叉树"><a href="#知道前序遍历和中序遍历构建二叉树" class="headerlink" title="知道前序遍历和中序遍历构建二叉树"></a>知道前序遍历和中序遍历构建二叉树</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;recursive version</span><br><span class="line">TreeNode* buildTree(vector&lt;int&gt;&amp; preorder, int pbegin, int pend, vector&lt;int&gt;&amp; inorder, int ibegin, int iend) &#123;</span><br><span class="line">    TreeNode* root &#x3D; new TreeNode(preorder[pbegin]);</span><br><span class="line"></span><br><span class="line">    int root_index;</span><br><span class="line">    for (root_index &#x3D; ibegin; root_index &lt;&#x3D; iend; ++root_index) &#123;</span><br><span class="line">        if (inorder[root_index] &#x3D;&#x3D; preorder[pbegin]) &#123;</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (root_index &gt; ibegin)</span><br><span class="line">        root-&gt;lson &#x3D; buildTree(preorder, pbegin+1, pbegin+root_index-ibegin, inorder, ibegin, root_index-1);</span><br><span class="line">    if (root_index &lt; iend)</span><br><span class="line">        root-&gt;rson &#x3D; buildTree(preorder, pbegin+root_index-ibegin+1, pend, inorder, root_index+1, iend);</span><br><span class="line"></span><br><span class="line">    return root;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">TreeNode* buildTree(vector&lt;int&gt;&amp; preorder, vector&lt;int&gt;&amp; inorder) &#123;</span><br><span class="line">    if (preorder.size() &#x3D;&#x3D; 0) &#123;</span><br><span class="line">        return nullptr;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return buildTree(preorder, 0, preorder.size()-1, inorder, 0, inorder.size()-1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;non-recursive version</span><br><span class="line">TreeNode* buildTree(vector&lt;int&gt;&amp; preorder, vector&lt;int&gt;&amp; inorder) &#123;</span><br><span class="line">    if (preorder.size() &#x3D;&#x3D; 0) &#123;</span><br><span class="line">        return nullptr;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;用于存储当前根结点中未考虑右子树的祖先结点</span><br><span class="line">    stack&lt;TreeNode*&gt; s;</span><br><span class="line">    TreeNode* root &#x3D; new TreeNode(preorder[0]); </span><br><span class="line">    s.push(root);</span><br><span class="line">    TreeNode *prev;</span><br><span class="line">    &#x2F;&#x2F;指向当前根结点最左侧的结点在中序遍历中的下标</span><br><span class="line">    int index &#x3D; 0;        </span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;遍历每一个结点</span><br><span class="line">    for (int i &#x3D; 1; i &lt; preorder.size(); ++i) &#123;</span><br><span class="line">        prev  &#x3D; s.top();</span><br><span class="line">        &#x2F;&#x2F;若为右儿子或祖先结点的右儿子</span><br><span class="line">        if (prev-&gt;val &#x3D;&#x3D; inorder[index]) &#123;</span><br><span class="line">            while (!s.empty() &amp;&amp; inorder[index] &#x3D;&#x3D; s.top()-&gt;val) &#123;</span><br><span class="line">                ++index;</span><br><span class="line">                prev &#x3D; s.top();</span><br><span class="line">                s.pop();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            prev-&gt;rson &#x3D; new TreeNode(preorder[i]);</span><br><span class="line">            s.push(prev-&gt;rson);</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F;若为左儿子</span><br><span class="line">        else &#123;</span><br><span class="line">            prev-&gt;lson &#x3D; new TreeNode(preorder[i]);</span><br><span class="line">            s.push(prev-&gt;lson);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return root;       </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="知道中序遍历和后续遍历构建二叉树"><a href="#知道中序遍历和后续遍历构建二叉树" class="headerlink" title="知道中序遍历和后续遍历构建二叉树"></a>知道中序遍历和后续遍历构建二叉树</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;recursive version</span><br><span class="line">TreeNode* buildTree(vector&lt;int&gt;&amp; inorder, int ibegin, int iend, vector&lt;int&gt;&amp; postorder, int pbegin, int pend) &#123;</span><br><span class="line">    TreeNode* root &#x3D; new TreeNode(postorder[pend]);</span><br><span class="line"></span><br><span class="line">    int index;</span><br><span class="line">    for (index &#x3D; ibegin; index &lt;&#x3D; iend; ++index) &#123;</span><br><span class="line">        if (inorder[index] &#x3D;&#x3D; postorder[pend]) &#123;</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (index &gt; ibegin)</span><br><span class="line">        root-&gt;lson &#x3D; buildTree(inorder, ibegin, index-1, postorder, pbegin, pbegin+index-ibegin-1);</span><br><span class="line">    if (index &lt; iend)</span><br><span class="line">        root-&gt;rson &#x3D; buildTree(inorder, index+1, iend, postorder, pbegin+index-ibegin, pend-1);</span><br><span class="line"></span><br><span class="line">    return root;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">TreeNode* buildTree(vector&lt;int&gt;&amp; inorder, vector&lt;int&gt;&amp; postorder) &#123;</span><br><span class="line">    if (inorder.size() &#x3D;&#x3D; 0) &#123;</span><br><span class="line">        return nullptr;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return buildTree(inorder, 0, inorder.size()-1, postorder, 0, postorder.size()-1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;non-recursive version</span><br><span class="line">TreeNode* buildTree(vector&lt;int&gt;&amp; inorder, vector&lt;int&gt;&amp; postorder) &#123;</span><br><span class="line">    if (inorder.size() &#x3D;&#x3D; 0) &#123;</span><br><span class="line">        return nullptr;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    TreeNode *root &#x3D; new TreeNode(postorder[postorder.size()-1]), *prev;</span><br><span class="line">    stack&lt;TreeNode*&gt; s;</span><br><span class="line">    s.push(root);</span><br><span class="line">    int index &#x3D; inorder.size()-1;</span><br><span class="line"></span><br><span class="line">    for (int i &#x3D; postorder.size()-2; i &gt;&#x3D; 0; --i) &#123;</span><br><span class="line">        prev &#x3D; s.top();</span><br><span class="line"></span><br><span class="line">        if (inorder[index] &#x3D;&#x3D; prev-&gt;val) &#123;</span><br><span class="line">            while (!s.empty() &amp;&amp; s.top()-&gt;val &#x3D;&#x3D; inorder[index]) &#123;</span><br><span class="line">                prev &#x3D; s.top();</span><br><span class="line">                s.pop();</span><br><span class="line">                --index;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            prev-&gt;lson &#x3D; new TreeNode(postorder[i]);</span><br><span class="line">            s.push(prev-&gt;lson);</span><br><span class="line">        &#125; </span><br><span class="line">        else &#123;</span><br><span class="line">            prev-&gt;rson &#x3D; new TreeNode(postorder[i]);</span><br><span class="line">            s.push(prev-&gt;rson);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>数据结构</category>
        <category>树</category>
      </categories>
  </entry>
</search>
